
console.log("Initializing context. Reading msg and node from Node.IO");
//  Use import instead
// const WASI = require('wasi');
// console.log(WASI.WASI);
// const fs = require('fs');
const debug = "{{{ debug }}}" || false;




GLOBAL_CACHE = GLOBAL_CACHE || this.GLOBAL_CACHE ;  
start = start || (() => {});

  let wasm = GLOBAL_CACHE["{{{ wasmfile }}}"];
  const wasi = new WASI.WASI({
      version: 'preview1',
      args: [ /* empty for now */ ],
      env: { /* empty for now */ },
      preopens: {
        // '/sandbox': '/dev/',
      },
    });

  // The result if the STACK
  let GLOBAL_RESULT = [];
  // The instantiation of the Wasm module can be avoided every time 
  // if for example, we have a pool of instances previously
  const instance = await WebAssembly.instantiate(wasm, {
    ...wasi.getImportObject(),
    "env": {
      "node_red_msg_size": function() {
         // Return the size in bytes of the message encoded as a JSON string 
         let json = JSON.stringify(msg);
         let buffer = new TextEncoder().encode(json);
         if(debug)  console.log("Sending msg size", buffer.byteLength);
         return buffer.byteLength;
      },
      "node_red_node_size": function() {
        // Return the size in bytes of the message encoded as a JSON string 
        let json = JSON.stringify(node);
        let buffer = new TextEncoder().encode(json);
        if(debug) console.log("Sending node struct size", buffer.byteLength);
        return buffer.byteLength;
     },
      "node_red_msg": function(data, offset, length){
        let json = JSON.stringify(msg);
        let buffer = new TextEncoder().encode(json);
        let bytes = new Uint8Array(instance.exports.memory.buffer, data + offset, length);
        bytes.set(buffer);
        if(debug)  console.log("Sending msg", data, offset, length);
        return buffer.byteLength;
      },
      "node_red_node": function(data, offset, length){
        let json = JSON.stringify(node);
        let buffer = new TextEncoder().encode(json);
        let bytes = new Uint8Array(instance.exports.memory.buffer, data + offset, length);
        bytes.set(buffer);
        if(debug) console.log("Sending node", data, offset, length);
        return buffer.byteLength;
      },
      "node_red_send": function(data, offset, length){
        console.log("Sending data", data, offset, length);
        let d =  instance.exports.memory.buffer.slice(data + offset, data + offset + length);
        let buffer = new Uint8Array(d);
        let encoded = new TextDecoder().decode(buffer);
        // The message is changed here
        msg = JSON.parse(encoded);
        if(debug) console.log("Calling node send", data, offset, length);
        node.send(msg)
      },
      "node_red_done": function(data, offset, length){
        //console.log("Done data", data, offset, length);
        let d =  instance.exports.memory.buffer.slice(data + offset, data + offset + length);
        let buffer = new Uint8Array(d);
        let encoded = new TextDecoder().decode(buffer);
        // The message is changed here
        if(encoded){
            msg = JSON.parse(encoded);
            if(debug) console.log("Calling node done", data, offset, length);
            node.done(msg)
        }
        else 
        {
          if(debug) console.log("Calling node done", data, offset, length);
          node.done()
        }
      },
      "node_red_result": function(data, offset, length){
        console.log("Setting global result");
        // Set a custom value here
        let d =  instance.exports.memory.buffer.slice(data + offset, data + offset + length);
        let buffer = new Uint8Array(d);
        let encoded = new TextDecoder().decode(buffer);
        data = JSON.parse(encoded);

        GLOBAL_RESULT.push(data);
      }
    }
  });

  // Start the timer here to se the impact of the instantiation
  // Move it along to include other computations, for example the call to WebAssembly instantiate
  start()
  wasi.start(instance);
  let r = GLOBAL_RESULT.pop();
  return r
