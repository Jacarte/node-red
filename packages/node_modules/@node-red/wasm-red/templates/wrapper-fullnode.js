import red_util from 'red_util';
import red_log from 'red_log';
import process from 'process';

{{{
  inner_code
}}}

let MODE = "Register";
let CL = 'constructorname';

const recursivehandler  = {
  get(target, prop, receiver) {
      if(prop in target) {
          return new Proxy(target[prop], recursivehandler)
      }
      return () => {
          console.log("Not implemented", prop, "for", target);
          // TODO ask the host for this property
          return new Proxy(target, recursivehandler)
      }
  },
};



// Callbacks for on('input', callback)
let callbacks = {

}

// Inside context
let CONTEXT = {};


// Wraps the communication with the host context object
function wrapcontext(obj){
  obj.context = function(){
      let r = Node.IO.context();
      // The new coming and the already saved here
      // so every time it is requested, the outside values are 
      // wiped out ? 
      // TODO check policy here
      CONTEXT = {...r, ...CONTEXT};
      return {
        ...CONTEXT,
        // This is for the 10-function node
        global: {
          get(key){
            console.log("TODO, requesting from global", key);
          },
          set(key, value){
            console.log("TODO, setting global", key, value);
          }
        },
        set(key, value){
          CONTEXT[key] = value;
          // TODO call the host
        },
        get(key){
          // TODO call the host
          if(CONTEXT[key]){
            return CONTEXT[key];
          }
          return undefined
        }
      }
  }
}

function initialize(CL){
   // Get the node from the host
    let node = Node.IO.node();
    // set a function as its context
    wrapcontext(node);

    let pnode = new Proxy(node, {
       set(obj, prop, value){
           console.log("Setting", prop, "to", obj, "as", value);
       }
    });

    // A wrapper for the node instance
    // It communicates with the host 
    
    let self = {
        ...node,
        on: function(event, callback){
          if(!callbacks[event])
            callbacks[event] = [];
          callbacks[event].push(callback.bind(self));
        },
        send: function(msg){
           Node.IO.send(msg)
        },
        done: function(msg){
          Node.IO.done(msg)
        },
        error: function(err, msg){
          // console.log("[WASM] err", err);
          Node.IO.error(msg);
        },
        warn: function(msg){
          Node.IO.warn(msg)
        },
        status(payload){
          // Node.IO.status(payload)
          console.log(JSON.stringify(payload))
        },
        filename: './input.txt'
    };

    let bound = CL.bind(self);
    bound(pnode);
    //console.log("[WASM] self", JSON.stringify(self));
}

const RED = {
  _(msg){
    // THis is usually i18n
    // We skip its implementation for now
    // Ideally should be a comm between the host and the wasm 
    return msg;
  },
  util: red_util,
  log: red_log,
  settings: {
    fileWorkingDirectory: ''
  },
  library: {
    register(name){
      //console.log("Register", name);
    }
  },
  nodes: {
    registerType: function (name, constructor, options = {}) {

      const constructorname = constructor.name || name;
      // This call the host to register itself
      //console.log("[WASM] Setting register:", constructorname);
      this.constructorname = constructor;
      if(MODE == 'Register'){
        //console.log("[WASM] registering node", name, constructorname);
        Node.IO.register_type(
          name, constructorname, options
        )
      }
      if(MODE === 'Init' && constructorname === CL){
        initialize(constructor)
      }
    },
    createNode: function (self, node) {
      node = { ...Node.IO.node()  };
      wrapcontext(node);
      //console.log("Do something with this. create Node")
      // node.nodes.createNode(self, node);
    }
  }
}
/*
function new(constructorname){
  console.log("Initializing the node", constructorname);
  module.exports(RED)[constructorname];
}*/

export function javyregisternode() {
  let command = Node.IO.pop();

  //console.log("[WASM] Command", JSON.stringify(command));
  if(command.type === 'register'){
      MODE = 'Register';
  }else {
    throw Exception("Invalid command for Register");
  }
  nodemod(RED);
  
  // console.log("register node")
}


export function javyinit() {
  let command = Node.IO.pop();

  //console.log("[WASM] Command", JSON.stringify(command));
  if(command.type === 'init'){
      MODE = 'Init'; 
      CL = command.name;
  } else {
      throw Exception("Invalid command for init");
  }
  nodemod(RED);
  
  // console.log("register node")
}

export function javyprocessmessage(){
  let command = Node.IO.pop();
  //console.log("[WASM] processing", JSON.stringify(command));
  if(command.type == 'on'){
     let eventname = command.event;
    
     for(let cb of callbacks[eventname]){
       cb(command.msg, Node.IO.send, Node.IO.done);
     }
  }
}


