import red_util from 'red_util';
import red_log from 'red_log';

{{{
  inner_code
}}}

let MODE = "Register";
let CL = 'constructorname';

const recursivehandler  = {
  get(target, prop, receiver) {
      if(prop in target) {
          return new Proxy(target[prop], recursivehandler)
      }
      return () => {
          console.log("Not implemented", prop, "for", target);
          // TODO ask the host for this property
          return new Proxy(target, recursivehandler)
      }
  },
};

// Callbacks for on('input', callback)
let callbacks = {

}

function initialize(CL){
   // Get the node from the host
    let node = Node.IO.node();
    let pnode = new Proxy(node, {
       set(obj, prop, value){
           console.log("Setting", prop, "to", obj, "as", value);
       }
    });

    // A wrapper for the node instance
    // It communicates with the host 
    
    let self = {
        ...node,
        on: function(event, callback){
          if(!callbacks[event])
            callbacks[event] = [];
          callbacks[event].push(callback);
        },
        send: function(msg){
           Node.IO.send(msg)
        },
        done: function(msg){
          Node.IO.done(msg)
        },
        warn: function(msg){
          Node.IO.warn(msg)
        },
        filename: './input.txt'
    };
    let bound = CL.bind(self);
    bound(pnode);
    console.log("[WASM] self", JSON.stringify(self));
}

const RED = {
  _(msg){
    // THis is usually i18n
    // We skip its implementation for now
    // Ideally should be a comm between the host and the wasm 
    return msg;
  },
  util: red_util,
  log: red_log,
  settings: {
    fileWorkingDirectory: 'javy_vm'
  },
  nodes: {
    registerType: function (name, constructor, options = {}) {

      const constructorname = constructor.name || name;
      // This call the host to register itself
      console.log("[WASM] Setting register:", constructorname);
      this.constructorname = constructor;
      if(MODE == 'Register'){
        console.log("[WASM] registering node", name, constructorname);
        Node.IO.register_type(
          name, constructorname, options
        )
      }
      if(MODE === 'Init' && constructorname === CL){
        initialize(constructor)
      }
    },
    createNode: function (self, node) {
      node = { ...Node.IO.node() };
      console.log("Do something with this. create Node")
      // node.nodes.createNode(self, node);
    }
  }
}
/*
function new(constructorname){
  console.log("Initializing the node", constructorname);
  module.exports(RED)[constructorname];
}*/

export function javyregisternode() {
  let command = Node.IO.pop();

  console.log("[WASM] Command", JSON.stringify(command));
  if(command.type === 'register'){
      MODE = 'Register';
  }else {
    throw Exception("Invalid command for Register");
  }
  nodemod(RED);
  
  // console.log("register node")
}


export function javyinit() {
  let command = Node.IO.pop();

  console.log("[WASM] Command", JSON.stringify(command));
  if(command.type === 'init'){
      MODE = 'Init'; 
      CL = command.name;
  } else {
      throw Exception("Invalid command for init");
  }
  nodemod(RED);
  
  // console.log("register node")
}

export function javyprocessmessage(){
  let command = Node.IO.pop();
  console.log("[WASM] processing", JSON.stringify(command));
  if(command.type == 'on'){
     let eventname = command.event;
    
     for(let cb of callbacks[eventname]){
       cb(command.msg, Node.IO.send, Node.IO.done);
     }
  }
}


