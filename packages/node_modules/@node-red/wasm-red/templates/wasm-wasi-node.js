
const WASI = require("wasi");
const debug = "{{{ debug }}}" || false;

function getWasi(){
  const wasi = new WASI.WASI({
    version: 'preview1',
    args: [ /* empty for now */ ],
    env: { /* empty for now */ },
    preopens: {
      // '/sandbox': '/dev/',
    },
  });

  return wasi
}



function get_context(RED, COMMAND_QUEUE, node, instancecb, world = ""){
  return {
    "env": {
      "node_red_pop_size": function() {
        let peek = COMMAND_QUEUE.pop();
        let json = JSON.stringify(peek);
        let buffer = new TextEncoder().encode(json);
        if(debug)  console.log("Sending command size", buffer.byteLength, `[${world}]`);
        COMMAND_QUEUE.push(peek);
        return buffer.byteLength;
      },

      "node_red_pop": function(data, offset, length) {
        // console.log("QUEUE", COMMAND_QUEUE);
        let json = JSON.stringify(COMMAND_QUEUE.pop());
        let buffer = new TextEncoder().encode(json);
        let bytes = new Uint8Array(instancecb().exports.memory.buffer, data + offset, length);
        bytes.set(buffer);
        if(debug)  console.log("Sending command", data, offset, length, `[${world}]`);
        return buffer.byteLength;
      },

      "node_red_msg_size": function() {
          // Return the size in bytes of the message encoded as a JSON string 
          let json = JSON.stringify(msg);
          let buffer = new TextEncoder().encode(json);
          if(debug)  console.log("Sending msg size", buffer.byteLength, `[${world}]`);
          return buffer.byteLength;
      },
      "node_red_node_size": function() {
        // Return the size in bytes of the message encoded as a JSON string 
        let json = JSON.stringify(node);
        let buffer = new TextEncoder().encode(json);
        if(debug) console.log("Sending node struct size", buffer.byteLength, `[${world}]`);
        return buffer.byteLength;
      },
      "node_red_msg": function(data, offset, length){
        let json = JSON.stringify(msg);
        let buffer = new TextEncoder().encode(json);
        let bytes = new Uint8Array(instancecb().exports.memory.buffer, data + offset, length);
        bytes.set(buffer);
        if(debug)  console.log("Sending msg", data, offset, length, `[${world}]`);
        return buffer.byteLength;
      },
      "node_red_node": function(data, offset, length){
        let json = JSON.stringify(node);
        let buffer = new TextEncoder().encode(json);
        let bytes = new Uint8Array(instancecb().exports.memory.buffer, data + offset, length);
        bytes.set(buffer);
        if(debug) console.log("Sending node", data, offset, length, `[${world}]`);
        return buffer.byteLength;
      },
      "node_red_send": function(data, offset, length){
        console.log("Sending data", data, offset, length);
        let d =  instancecb().exports.memory.buffer.slice(data + offset, data + offset + length);
        let buffer = new Uint8Array(d);
        let encoded = new TextDecoder().decode(buffer);
        // The message is changed here        
        console.log(encoded);

        msg = JSON.parse(encoded);
        if(debug) console.log("Calling node send", data, offset, length, `[${world}]`);
        instancecb().send(msg)
      },
      "node_red_done": function(data, offset, length){
        //console.log("Done data", data, offset, length);
        let d =  instancecb().exports.memory.buffer.slice(data + offset, data + offset + length);
        let buffer = new Uint8Array(d);
        let encoded = new TextDecoder().decode(buffer);
        console.log(encoded);
        // The message is changed here
        if(encoded){
            msg = JSON.parse(encoded);
            if(debug) console.log("Calling node done", data, offset, length, `[${world}]`);
            instancecb().done(msg)
        }
        else 
        {
          if(debug) console.log("Calling node done", data, offset, length, `[${world}]`);
          instancecb().done()
        }
      },
      "node_red_warn": function(data, offset, length){
        //console.log("Done data", data, offset, length);
        let d =  instancecb().exports.memory.buffer.slice(data + offset, data + offset + length);
        let buffer = new Uint8Array(d);
        let encoded = new TextDecoder().decode(buffer);
        console.log("Warn", encoded);
        // The message is changed here
        if(encoded){
            msg = JSON.parse(encoded);
            if(debug) console.log("Calling node done", data, offset, length, `[${world}]`);
            if(instancecb().warn)
              instancecb().warn(msg)
        }
      },
      "node_red_result": function(data, offset, length){
        console.log("Setting global result", `[${world}]`);
        // Set a custom value here
        let d =  instance().exports.memory.buffer.slice(data + offset, data + offset + length);
        let buffer = new Uint8Array(d);
        let encoded = new TextDecoder().decode(buffer);
        data = JSON.parse(encoded);

        GLOBAL_RESULT.push(data);
      },

      "node_red_register": function(data, offset, length){
        // Set a custom value here
        let d =  instancecb().exports.memory.buffer.slice(data + offset, data + offset + length);
        let buffer = new Uint8Array(d);
        let encoded = new TextDecoder().decode(buffer);
        data = JSON.parse(encoded);

        
        console.log("[Wrapper] Registering node", data, `[${world}]`);
        console.log("[Wrapper] making a stateful instance", instancecb(), `[${world}]`);
        function wrappernode(newnode){
            RED.nodes.createNode(this, newnode);
            
           // Here we instantiate a node with the same properties as the one we are wrapping
            console.log("Calling node constructor");
           let [wasm, address] = RED.GLOBAL_CACHE["{{{ wasmfile }}}"];
           // Should be save the instance to keep a state ?
           // TODO do we need a fresh instance of WASI ?
           const wasi = getWasi();
           // TODO do we need a fresh instance of Wasm
           const instance = new WebAssembly.Instance(wasm, {
              ...wasi.getImportObject(),
              ...get_context(RED, COMMAND_QUEUE, newnode, () => instance /**/, "instance")
            });
            
           COMMAND_QUEUE.push({
              "type": "init",
              "name": data.constructor
            })

            instance.warn = newnode.warn;
            wasi.start(instance);
            instance.exports.javyinit();


           // instance.exports.invoke to initialize the instance and its initial state
           this.on('input', function(msg, send, done, warn) {
              
              instance.send = send;
              instance.done = done;
              instance.warn = warn || newnode.warn ;
              COMMAND_QUEUE.push({
                "type": "on",
                "event": "input",
                "msg": msg
              })
              
              instance.exports.javyprocessmessage();
              // instance.exports.on("input", msg);
           });
        };
        RED.nodes.registerType(data.name, wrappernode, data.options);
        console.log("[Wrapper] Node registered", `[${world}]`);
      }

   }
  }
}

module.exports = function(RED){
    
    // Since the entry point of the module is always the same, we need to 
    // address their behavior by passing messages to it
    let COMMAND_QUEUE = [];
    
    console.log("Initializing context. Reading Global cache", RED.GLOBAL_CACHE);
    let [wasm, address] = RED.GLOBAL_CACHE["{{{ wasmfile }}}"];
    
    const wasi = getWasi();

    console.log("Wasi loaded");
    // The instantiation of the Wasm module can be avoided every time 
    // if for example, we have a pool of instances previously
    const instance = new WebAssembly.Instance(wasm, {
      ...wasi.getImportObject(),
      // This is a static stage, so, no node instace neither Wasm instance
      ...get_context(RED, COMMAND_QUEUE, null, () => instance, "register")
    });
    
    console.log("Instance created. Calling start to invoke the node registration");
    // Start the timer here to se the impact of the instantiation
    // Move it along to include other computations, for example the call to WebAssembly instantiate
    COMMAND_QUEUE.push({
      "type": "register",
    })
    wasi.start(instance);
    instance.exports.javyregisternode()
}