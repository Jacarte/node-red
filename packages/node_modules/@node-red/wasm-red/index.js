const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const types = require('@babel/types');
const generator = require('@babel/generator').default;
const fs = require('fs');
const mustache =require('mustache');
const { Exception } = require('sass');

function _(c) {
    try{
        return c()
    } catch(e) {
        // console.log(e)
    }
}

module.exports = {
    wasmwrap : function(node) {
        let f = node.file;
        
        console.log(node.name, f)
        // Read the JavaScript file
        const code = fs.readFileSync(f, 'utf-8');
        let rr = require(f);


        // Parse the code into an AST
        const ast = parser.parse(code, {
        sourceType: 'module',
            plugins: [
                // Enable any necessary syntax plugins here
        ],
        });


        // Traverse the AST

        // We go bottom up
        // The easiest transformation is a single arithm instruction
        // We need to take all "requires" to run rollup on them

        let idval = {};
        let declarations = [];
        let dependencies = [];

        traverse(ast, {
            // Parse the require statements
            // Group them all to ask for rollup
            VariableDeclaration(path) {
                const names = path.node.declarations.map((d) => [d.id.name, d.init, d, d.type]);
                // Add the declarations as nodes
                
                for(let n of names) {
                    // console.log(n);
                    let init = n[1];
                    let name = n[0];
                    //console.log("Adding declaration", name);
                    _(() => {
                    const id = types.identifier(name);
                    declarations.push(
                        types.variableDeclaration("let", [
                            types.variableDeclarator(id)
                        ])
                    );
                    declarations.push(types.tryStatement(
                        types.blockStatement([
                            types.expressionStatement(
                                types.assignmentExpression("=", id, init)
                            )
                        ]), types.catchClause(types.identifier("e"), types.blockStatement([
                            //types.expressionStatement(types.callExpression(types.identifier("console.log"), [types.identifier("e")]))
                        ]))
                    ), );

                    })
                }

                // console.log("Declarations added");
                for(let n of names) {
                    let init = n[1];
                    let name = n[0];

                    if(init.type == "CallExpression" && init.callee.name == "require") {
                        // Save this a dependency
                        dependencies.push(n[2]);
                    }

                    // Just try to eval
                    // Just add all declarations one after the other to the declarations array
                    let previous = _(() =>{
                        const ret = types.returnStatement(init);
                        // Create an empty function
                        return types.blockStatement([...declarations, ret ]);
                    })

                    //console.log("prev");
                    let code = _( () => generator(previous).code );
                    //console.log(code)
                    try {
                        // TODO watch out, this is dangerous
                        let value = new Function(code)();
                        idval[name] = value;

                    } catch(e) {
                       // console.log(e);
                    }

                    
                }
            },
            CallExpression(path) {
                const callee = path.node.callee;
                const name = path.node.callee.name;
                const tpe = callee.type;
                const pr = callee.property;
                // const methodName = callee.property.name;

                if(pr) {
                    // We are assuming that there is not other "on" call for "input" events
                    if(pr.name === "on") {
                        console.log(name, tpe, pr.name);
                        console.log("=================");

                        const arguments = path.node.arguments;
                        if(arguments.length > 1) {
                            const first = arguments[0];
                            // If it is a string, it is the event name
                            let eventname;
                            if(first.type === "StringLiteral") {
                                eventname = first.value;
                            } 
                            else {
                                // Track back the variable for the event name
                                console.log(first.type)
                                if(first.type === "Identifier") {
                                    console.log(first.name)
                                    // If it was seen then we can get the value
                                    if(idval[first.name]) {
                                        eventname = idval[first.name];
                                    }
                                }

                                // The other cases
                            }
                            console.log("\tEvent name", eventname);
                            if(eventname == "input") {
                                // The second argument is the function
                                const second = arguments[1];
                                
                                // Create a new main function from scratch


                                // Copy out it as a string
                                // TODO, do another pass to set the msg, send, done and get_node access
                                //let code = generator(second).code;
                                // Get the body of the code and create a named function
                                let functionmm = types.functionDeclaration(types.identifier("mm"), second.params, second.body, second.generator, second.async);

                                let rendered_wrapper = mustache.render(
                                    fs.readFileSync(`${__dirname}/templates/wrapper.js`, 'utf-8'), {
                                    inner_code: generator(functionmm).code,
                                    mm: 'mm',
                                    // Force dep as consts
                                    dependencies: dependencies.map((d) => `const ${generator(d).code}`),
                                    args: second.params.map((p) => p.name),
                                    debug: true
                                })


                                
                                // Add the requires
                                // Add the entry points

                                let r = fs.writeFileSync(`${f}.inner.js`, rendered_wrapper);
                                console.log("\tWasm Code generated !");
                                // replace it with a custom code
                                // Load the wasi_template
                                let template_path = `${__dirname}/templates/wasm-wasi.js`;
                                let rendered = mustache.render(fs.readFileSync(template_path, 'utf-8'), {
                                    wasmfile: `${f}.inner.wasm`,
                                })
                                // Change the second argument to be a function with the same signature as
                                // the original one, but with the body replaced by the wasm code
                                // TODO this can be a call to a variable that is declared as the listener :|
                                let signature = second.params.map((p) => types.identifier(p.name));
                                //console.log(signature);
                                //let body = rendered;
                                let parsed_template = // Parse the rendered code
                                parser.parse(rendered, {
                                    // allow async
                                    sourceType: 'module',
                                });
                                //console.log(parsed_template.program.body)
                                let newfunc = _(() => types.functionExpression(null, signature, 
                                    types.blockStatement(parsed_template.program.body), undefined, true
                                    ));
                                //console.log(newfunc);
                                arguments[1] = newfunc;
                                console.log("\JS Code generated !");
                            }
                        }
                    }
                }
            },
            // We do some replacement here if needed
        });

        // Now call rollup (or vivet) for the inner file


        const newCode = _(() => generator(ast).code);
        // Compile the whole AST to Wasm
        let thisdir = __dirname;
        let execS = require('child_process').execSync;
        
        let rollup = `rollup  ${f}.inner.js --config ${thisdir}/configs/rollup.config.js --bundleConfigAsCjs --file ${f}.bundle.inner.js`
        
        execS(rollup);

        // Patch the generated file
        let content = fs.readFileSync(`${f}.bundle.inner.js`, 'utf-8');
        // Is the last apparison of this
        let replace = content.replace(/main\(\);\n\nmodule.exports/g, "main();\n//module.exports");
        fs.writeFileSync(`${f}.bundle.inner.js`, replace);

        let cmd = `${thisdir}/javy/javy compile ${f}.bundle.inner.js -o ${f}.inner.wasm`;
        console.log("Compiling Wasm file")
        // Make exec sync
        let sync = true;

        let rrt = execS(cmd);
        console.log(rrt.toString());

        // TODO test the wrapping
        // If so, change the logo

        // Write the new code to a file
        console.log("Glue code generated");
        fs.writeFileSync(`${f}.wrapped.js`, newCode);
        console.log("Wrapper generated");
        // Do change meta in the html content

        // Change the icon in the HTML file corresponding to this JS
        // Remove previous extension
        let nonext = f.split(".")[0];
        let html_file = `${nonext}.html`;
        let html_content = fs.readFileSync(html_file, 'utf-8');
        // change the icon
        let new_html_content = html_content.replace(/icon: ".*"/, `icon: "wasm.png"`);
        // Save back
        fs.writeFileSync(html_file, new_html_content);

        return require(`${f}.wrapped.js`)
    }
}