const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const types = require('@babel/types');
const { filter } = require('cheerio/lib/api/traversing');
const generator = require('@babel/generator').default;
const fs = require('fs');
const mustache =require('mustache');
const { Exception } = require('sass');
const { v4: uuidv4 } = require('uuid');
const WASI = require("wasi");

const listenername = "mm";

let GLOBAL_CACHE = {}
let INSTANCE_CACHE = {}

const DEBUG = 1;

function get_package_json_folder(f) {

    // Start by this file and go to parent until package.json is found
    // make this a function
    let current = f;
    let found = false;
    while(!found) {
        let files = fs.readdirSync(current);
        if(files.includes("package.json")) {
            found = true;
        } else {
            current = current.split("/").slice(0, -1).join("/");
        }
    }
    return current;
}


function _(c, els = undefined) {
    try{
        return c()
    } catch(e) {
        console.log(e)

        if(els) {
            return _(els);
        }
    }
}

module.exports = {
    GLOBAL_CACHE: GLOBAL_CACHE,
    INSTANCE_CACHE: INSTANCE_CACHE,
    wasmwrap_code: function(node, ops = {}) {

        let wasm_wasi = `${__dirname}/templates/wasm-wasi-dyn.js`;

        if(ops.function_body) {
            if(DEBUG){
                console.log("[WASM-RED] Taking the body of the passed node");
                console.log(`[WASM-RED taking ${node}`)
            }
            const ast = _(() => parser.parseExpression(node, {
                errorRecovery: true,
                sourceType: 'script',
            }));

            console.log(ast)
            // Get the body of the ast as a function node
            let body = ast.body;
            // encode it back and return the string
            node = generator(body).code;

            wasm_wasi = `${__dirname}/templates/wasm-wasi.js`;
        }

        if(DEBUG){
            console.log(`[WASM-RED] wrapping \n===================\n'${node}'\n========================` )
        }
        let template_path = `${__dirname}/templates/wrapper.js`;
        // Render
        let rendered = mustache.render(fs.readFileSync(template_path, 'utf-8'), {
            inner_code: `function mm(){${node}}`,
            mm: "mm",
        });


        let thisdir = __dirname;
        let execS = require('child_process').execSync;

        // Creates a temporary file name
        let tmp = uuidv4();
        // tmp = `/tmp/${tmp}`;
        // For dev, comment out for deploy
        tmp = `${thisdir}/tmp/${tmp}`;

        // write to tmp file
        fs.writeFileSync(`${tmp}.js`, rendered);

        // Call rollup
        let rollup = `rollup  ${tmp}.js --config ${thisdir}/configs/rollup.config.js --bundleConfigAsCjs --file ${tmp}.bundle.inner.js`
            
        let filedir;

        if(ops && ops.cwd) {
            filedir = get_package_json_folder(ops.cwd)
        }else {
            filedir = get_package_json_folder(thisdir);
        }

        if(DEBUG){
            console.log("[WASM-RED]", filedir);
        }
        execS(rollup, {
            // Set the CWD on the folder of the file
            cwd: filedir
        });
        // Patch the generated file
        let content = fs.readFileSync(`${tmp}.bundle.inner.js`, 'utf-8');
        // Is the last apparison of this
        let replace = content.replace(/main\(\);\n\nmodule.exports/g, "main();\n//module.exports");
        replace = replace.replace(/modules.exports/g, "//modules.exports");

        fs.writeFileSync(`${tmp}.bundle.inner.js`, replace);

        
        // Call javy by default
        let cmd = `${thisdir}/bin/javy compile ${tmp}.bundle.inner.js -o ${tmp}.wasm`;
        
        if(DEBUG){
            console.log("[WASM-RED] Compiling Wasm file", `${tmp}.bundle.inner.js`);
        }
        let sync = true;

        let rrt = execS(cmd);
        let name = `${tmp}.wasm`;

        if(ops.optimize) {
            
            let cmd = `wasm-opt -all -O3 ${tmp}.wasm -o ${tmp}.opt.wasm`;
            if(DEBUG){
                console.log("[WASM-RED] Compiling Wasm file", `${tmp}.bundle.inner.js`);
            }
            let rrt = execS(cmd);
            name = `${tmp}.opt.wasm`;
            // Print the difference in size
            let size = fs.statSync(`${tmp}.wasm`).size;
            let size_opt = fs.statSync(`${tmp}.opt.wasm`).size;

            if(DEBUG){
                console.log(`[WASM-RED] Optimized from ${size} to ${size_opt} bytes (${size_opt/size*100}%)`);
            }
        }
        // hash the node code

        let wasmbytes = fs.readFileSync(name);
        // Compile the Wasm module
        WebAssembly.compile(
            fs.readFileSync(name),
        ).then(wasm => {
            if(DEBUG){
                console.log(`[WASM-RED] Compiled wasm to cache ${name}`);
            }
            GLOBAL_CACHE[name] = wasm;

            //console.log("Initializing")

            // Initialize

            const wasi = new WASI.WASI({
                version: 'preview1',
                args: [ /* empty for now */ ],
                env: { /* empty for now */ },
                preopens: {
                // '/sandbox': '/dev/',
                },
            });
            // The result if the STACK
            INSTANCE_CACHE[name] = {
                RESULT:[],
                INSTANCE: null
            }
            
            /*
            const instance = WebAssembly.instantiate(wasm, {
                ...wasi.getImportObject(),
                "env": {
                "node_red_msg_size": function() {
                    // Return the size in bytes of the message encoded as a JSON string 
                    let json = JSON.stringify(msg);
                    let buffer = new TextEncoder().encode(json);
                    if(debug)  console.log("Sending msg size", buffer.byteLength);
                    return buffer.byteLength;
                },
                "node_red_node_size": function() {
                    // Return the size in bytes of the message encoded as a JSON string 
                    let json = JSON.stringify(node);
                    let buffer = new TextEncoder().encode(json);
                    if(debug) console.log("Sending node struct size", buffer.byteLength);
                    return buffer.byteLength;
                },
                "node_red_msg": function(data, offset, length){
                    let json = JSON.stringify(msg);
                    let buffer = new TextEncoder().encode(json);
                    let bytes = new Uint8Array(instance.exports.memory.buffer, data + offset, length);
                    bytes.set(buffer);
                    if(debug)  console.log("Sending msg", data, offset, length);
                    return buffer.byteLength;
                },
                "node_red_node": function(data, offset, length){
                    let json = JSON.stringify(node);
                    let buffer = new TextEncoder().encode(json);
                    let bytes = new Uint8Array(instance.exports.memory.buffer, data + offset, length);
                    bytes.set(buffer);
                    if(debug) console.log("Sending node", data, offset, length);
                    return buffer.byteLength;
                },
                "node_red_send": function(data, offset, length){
                    console.log("Sending data", data, offset, length);
                    let d =  instance.exports.memory.buffer.slice(data + offset, data + offset + length);
                    let buffer = new Uint8Array(d);
                    let encoded = new TextDecoder().decode(buffer);
                    // The message is changed here
                    msg = JSON.parse(encoded);
                    if(debug) console.log("Calling node send", data, offset, length);
                    node.send(msg)
                },
                "node_red_done": function(data, offset, length){
                    //console.log("Done data", data, offset, length);
                    let d =  instance.exports.memory.buffer.slice(data + offset, data + offset + length);
                    let buffer = new Uint8Array(d);
                    let encoded = new TextDecoder().decode(buffer);
                    // The message is changed here
                    if(encoded){
                        msg = JSON.parse(encoded);
                        if(debug) console.log("Calling node done", data, offset, length);
                        node.done(msg)
                    }
                    else 
                    {
                    if(debug) console.log("Calling node done", data, offset, length);
                    node.done()
                    }
                },
                "node_red_result": function(data, offset, length){
                    //console.log("Setting global result");
                    // Set a custom value here
                    let d =  instance.exports.memory.buffer.slice(data + offset, data + offset + length);
                    let buffer = new Uint8Array(d);
                    let encoded = new TextDecoder().decode(buffer);
                    data = JSON.parse(encoded);

                    INSTANCE_CACHE[name].RESULT.push(data);
                }
                }
            }).then(instance => {
                console.log(`Instantiated modole ${name}`)
                INSTANCE_CACHE[name].INSTANCE = instance;
            });*/
        });

        // Initialize

        let rendered_wasm = mustache.render(fs.readFileSync(wasm_wasi, 'utf-8'), {
            wasmfile: name,
        })

        // This is jsut for debug, remove after
        fs.writeFileSync(`${tmp}.wrapper.js`, rendered_wasm);
        return [rendered_wasm, `${tmp}.wrapper.js`]
        // Render the code template
        // Return the call to the fresh Wasm code
    },
    wasmwrap_jseval: function(node, ops = {}) {
        
        const { duktapeEval, quickjsEval } = require('wasm-jseval');

        duktapeEval.getInstance().then(mod => {
            let r = mod.eval(node)
        })

    }
}