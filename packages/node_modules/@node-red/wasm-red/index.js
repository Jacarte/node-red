const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const types = require('@babel/types');
const { filter } = require('cheerio/lib/api/traversing');
const generator = require('@babel/generator').default;
const fs = require('fs');
const mustache =require('mustache');
const { Exception } = require('sass');
const { v4: uuidv4 } = require('uuid');
const WASI = require("wasi");
const path = require('node:path'); 
var crypto = require('crypto');

//const listenername = "mm";

let GLOBAL_CACHE = {}
let INSTANCE_CACHE = {}

const DEBUG = 1;

function get_package_json_folder(f, ops) {

    // Start by this file and go to parent until package.json is found
    // make this a function
    let current = f;
    // This is a patch !
    if(ops.full_node){
        return current;
    }

    let found = false;
    while(!found) {
        let files = fs.readdirSync(current);
        if(files.includes("package.json")) {
            found = true;
        } else {
            current = current.split("/").slice(0, -1).join("/");
        }
    }
    return current;
}


function _(c, els = undefined) {
    try{
        return c()
    } catch(e) {
        console.log(e)

        if(els) {
            return _(els);
        }
    }
}

module.exports = {
    GLOBAL_CACHE: GLOBAL_CACHE,
    INSTANCE_CACHE: INSTANCE_CACHE,
    wasmwrap_code: function(node, ops = {}, api_permissions = {}, package_permissions = {}) {

        if(ops.do_nothig){
            console.log("Doing nothing");
            return 'return msg'
        }
        // Hash the node to avoid collisions
        let filedir;

        if(ops && ops.cwd) {
            filedir = get_package_json_folder(ops.cwd, ops)
        }else {
            filedir = get_package_json_folder(thisdir, ops);
            filedir = `${filedir}/tmp_nodes`
        }

        

        var md5sum = crypto.createHash('md5');
        md5sum.update(node);
        let node_hash = md5sum.digest('hex');
        // Creates a temporary file name
        let tmp = `wasm-red.${node_hash}`;
        let listenername = node_hash;
                
        // tmp = `/tmp/${tmp}`;
        // For dev, comment out for deploy
        tmp = `${filedir}/${tmp}`;

        if(DEBUG) console.log("[WASM-RED] Hashing node: ", node_hash);
        if(false && node_hash in GLOBAL_CACHE && !ops.non_cache) { 
            if(DEBUG) console.log("[WASM-RED] Node already in cache");
            // Load the written code
            return GLOBAL_CACHE[node_hash];
        }
        // Check in the files system for the compilation result
        if(fs.existsSync(`${tmp}.wasm`) && !ops.non_cache) {
            // Load the written code
            
        }

        let wasm_wasi = `${__dirname}/templates/wasm-wasi-dyn.js`;

        if(ops.function_body) {
            if(DEBUG){
                console.log("[WASM-RED] Taking the body of the passed node");
                //console.log(`[WASM-RED taking ${node}`)
            }
            const ast = _(() => parser.parseExpression(node, {
                errorRecovery: true,
                sourceType: 'script',
            }));
            // Get the body of the ast as a function node
            let body = ast.body;
            // encode it back and return the string
            node = generator(body).code;
            wasm_wasi = `${__dirname}/templates/wasm-wasi.js`;
        }

        if(DEBUG){
            //    console.log(`[WASM-RED] wrapping \n===================\n'${node}'\n========================` )
        }
        let template_path = `${__dirname}/templates/wrapper.js`;
        let resolve_template_path = `${__dirname}/templates/custom-resolver-template.js`;
        let config_template_path = `${__dirname}/templates/rollup.config.template.js`;

        let nodecontent = node;
        if(ops.full_node){
            template_path = `${__dirname}/templates/wrapper-fullnode.js`;
            wasm_wasi = `${__dirname}/templates/wasm-wasi-node.js`;
            let filename = path.basename(ops.file);
            nodecontent = `import nodemod from './${filename}'`;
            // nodecontent = `const nodemod = require('./${filename}')`;
        }
        // Render
        let rendered = mustache.render(fs.readFileSync(template_path, 'utf-8'), {
            inner_code: ops.full_node? nodecontent : `function _${listenername}(){\n${nodecontent}\n}`,
            mm: `_${listenername}`,
        });


        let thisdir = __dirname;
        let execS = require('child_process').execSync;

        // Download the right version of javy first
        let _f = execS(`bash ${thisdir}/download-javy.sh`, {
            cwd: `${thisdir}/`
        });
        console.log("[WASM-RED] Downloaded javy", _f.toString());

        // write to tmp file
        fs.writeFileSync(`${tmp}.js`, rendered);

        // Call rollup
        // Render config first based in the node manifest

        let rendered_resolver= mustache.render(fs.readFileSync(resolve_template_path, 'utf-8'), {
            ...package_permissions
        });

        fs.writeFileSync(`${thisdir}/configs/resolve.${node_hash}.js`, rendered_resolver);
        console.log("[WASM-RED resolver written to", `resolver.${node_hash}.js`);


        let rendered_config = mustache.render(fs.readFileSync(config_template_path, 'utf-8'), {
            RESOLVER: `resolve.${node_hash}.js`
        });
        fs.writeFileSync(`${thisdir}/configs/config.${node_hash}.js`, rendered_config);

        let rollup = `rollup  ${tmp}.js --config ${thisdir}/configs/config.${node_hash}.js --bundleConfigAsCjs --file ${tmp}.bundle.inner.js`
        //let rollup = `esbuild  ${tmp}.js --bundle --platform=node --outfile=${tmp}.bundle.inner.js`
        
        if(DEBUG) console.log("[WASM-RED] Calling rollup: ", rollup);
        

        if(DEBUG){
            console.log("[WASM-RED] filedir", filedir);
        }
        _(() => execS(rollup, {
            // Set the CWD on the folder of the original file
            cwd: `${filedir}/`
        }));
        // Patch the generated file
        let content = fs.readFileSync(`${tmp}.bundle.inner.js`, 'utf-8');
        let replace= content;
        

        fs.writeFileSync(`${tmp}.bundle.inner.js`, replace);

        
        // Call javy by default
        console.log("[WASM-RED] calling Javy");
        let cmd = `${thisdir}/bin/javy compile --file-permissions ${thisdir}/templates/permissions.yaml --http-permissions ${thisdir}/templates/permissions-http.yaml --wit ${thisdir}/templates/export.wit -n "node-red" ${tmp}.bundle.inner.js -o ${tmp}.wasm`;
        
        if(DEBUG){
            console.log("[WASM-RED] Compiling Wasm file", `${tmp}.bundle.inner.js`);
        }
        let sync = true;

        let rrt = execS(cmd);
        let name = `${tmp}.wasm`;

        if(false){//ops.optimize) {
            
            let cmd = `wasm-opt -all -O3 ${tmp}.wasm -o ${tmp}.opt.wasm`;
            if(DEBUG){
                console.log("[WASM-RED] Compiling Wasm file", `${tmp}.bundle.inner.js`);
            }
            let rrt = execS(cmd);
            name = `${tmp}.opt.wasm`;
            // Print the difference in size
            let size = fs.statSync(`${tmp}.wasm`).size;
            let size_opt = fs.statSync(`${tmp}.opt.wasm`).size;

            if(DEBUG){
                console.log(`[WASM-RED] Optimized from ${size} to ${size_opt} bytes (${size_opt/size*100}%)`);
            }
        }
        // hash the node code

        // let wasmbytes = fs.readFileSync(name);
        // Compile the Wasm module
        let wasm = new WebAssembly.Module(
            fs.readFileSync(name),
        );

        if(DEBUG){
            console.log(`[WASM-RED] Compiled wasm to cache ${name}`);
        }
        GLOBAL_CACHE[node_hash] = [wasm, `${tmp}.wrapper.js`];

        // The result if the STACK
        INSTANCE_CACHE[node_hash] = {
            RESULT:[],
            INSTANCE: null
        }

        // Initialize
        console.log("[WASM-RED] rendering", wasm_wasi);

        let rendered_wasm = mustache.render(fs.readFileSync(wasm_wasi, 'utf-8'), {
            wasmfile: node_hash,
            debug: 1,
            time: ops.time,

            // Here the compiling time permissions, 
            // If they are not set, the wrapper functions wont be generated
            ...api_permissions,
            /*CAN_OPERATE_COMMANDS: true,
            CAN_READ_MSG: true,
            CAN_READ_NODE: true,
            CAN_READ_CONTEXT: true,
            CAN_SEND: true,
            CAN_WARN: true,
            CAN_DONE: true,
            CAN_PUSH_RESULT: true,
            CAN_ERROR: true,
            CAN_EMIT: true*/
        })

        // This is jsut for debug, remove after
        fs.writeFileSync(`${tmp}.wrapper.js`, rendered_wasm);
        return [rendered_wasm, `${tmp}.wrapper.js`]
        // Render the code template
        // Return the call to the fresh Wasm code
    },
    wasmwrap_jseval: function(node, ops = {}) {
        
        const { duktapeEval, quickjsEval } = require('wasm-jseval');

        duktapeEval.getInstance().then(mod => {
            let r = mod.eval(node)
        })

    }
}