const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const types = require('@babel/types');
const { filter } = require('cheerio/lib/api/traversing');
const generator = require('@babel/generator').default;
const fs = require('fs');
const mustache =require('mustache');
const { Exception } = require('sass');
const { v4: uuidv4 } = require('uuid');
const WASI = require("wasi");
const path = require('node:path'); 
var crypto = require('crypto');

//const listenername = "mm";

let GLOBAL_CACHE = {}
let INSTANCE_CACHE = {}

const DEBUG = 1;

function get_package_json_folder(f, ops) {

    // Start by this file and go to parent until package.json is found
    // make this a function
    let current = f;
    // This is a patch !
    if(ops.full_node){
        return current;
    }

    let found = false;
    while(!found) {
        let files = fs.readdirSync(current);
        if(files.includes("package.json")) {
            found = true;
        } else {
            current = current.split("/").slice(0, -1).join("/");
        }
    }
    return current;
}


function _(c, els = undefined) {
    try{
        return c()
    } catch(e) {
        console.log(e)

        if(els) {
            return _(els);
        }
    }
}

module.exports = {
    GLOBAL_CACHE: GLOBAL_CACHE,
    INSTANCE_CACHE: INSTANCE_CACHE,
    wasmwrap_code: function(node, ops = {}) {

        if(ops.do_nothig){
            console.log("Doing nothing");
            return 'return msg'
        }
        // Hash the node to avoid collisions
        let filedir;

        if(ops && ops.cwd) {
            filedir = get_package_json_folder(ops.cwd, ops)
        }else {
            filedir = get_package_json_folder(thisdir, ops);
            filedir = `${filedir}/tmp_nodes`
        }

        

        var md5sum = crypto.createHash('md5');
        md5sum.update(node);
        let node_hash = md5sum.digest('hex');
        // Creates a temporary file name
        let tmp = `wasm-red.${node_hash}`;
        let listenername = node_hash;
                
        // tmp = `/tmp/${tmp}`;
        // For dev, comment out for deploy
        tmp = `${filedir}/${tmp}`;

        if(DEBUG) console.log("[WASM-RED] Hashing node: ", node_hash);
        if(false && node_hash in GLOBAL_CACHE && !ops.non_cache) { 
            if(DEBUG) console.log("[WASM-RED] Node already in cache");
            // Load the written code
            return GLOBAL_CACHE[node_hash];
        }
        // Check in the files system for the compilation result
        if(fs.existsSync(`${tmp}.wasm`) && !ops.non_cache) {
            // Load the written code
            
        }

        let wasm_wasi = `${__dirname}/templates/wasm-wasi-dyn.js`;

        if(ops.function_body) {
            if(DEBUG){
                console.log("[WASM-RED] Taking the body of the passed node");
                //console.log(`[WASM-RED taking ${node}`)
            }
            const ast = _(() => parser.parseExpression(node, {
                errorRecovery: true,
                sourceType: 'script',
            }));
            // Get the body of the ast as a function node
            let body = ast.body;
            // encode it back and return the string
            node = generator(body).code;
            wasm_wasi = `${__dirname}/templates/wasm-wasi.js`;
        }

        if(DEBUG){
            //    console.log(`[WASM-RED] wrapping \n===================\n'${node}'\n========================` )
        }
        let template_path = `${__dirname}/templates/wrapper.js`;

        let nodecontent = node;
        if(ops.full_node){
            template_path = `${__dirname}/templates/wrapper-fullnode.js`;
            wasm_wasi = `${__dirname}/templates/wasm-wasi-node.js`;
            let filename = path.basename(ops.file);
            nodecontent = `import nodemod from './${filename}'`;
            // nodecontent = `const nodemod = require('./${filename}')`;
        }
        // Render
        let rendered = mustache.render(fs.readFileSync(template_path, 'utf-8'), {
            inner_code: ops.full_node? nodecontent : `function _${listenername}(){\n${nodecontent}\n}`,
            mm: `_${listenername}`,
        });


        let thisdir = __dirname;
        let execS = require('child_process').execSync;

        

        // write to tmp file
        fs.writeFileSync(`${tmp}.js`, rendered);

        // Call rollup
        let rollup = `rollup  ${tmp}.js --config ${thisdir}/configs/rollup.config.js --bundleConfigAsCjs --file ${tmp}.bundle.inner.js`
        //let rollup = `esbuild  ${tmp}.js --bundle --platform=node --outfile=${tmp}.bundle.inner.js`
        
        if(DEBUG) console.log("[WASM-RED] Calling rollup: ", rollup);
        

        if(DEBUG){
            console.log("[WASM-RED] filedir", filedir);
        }
        _(() => execS(rollup, {
            // Set the CWD on the folder of the original file
            cwd: `${filedir}/`
        }));
        // Patch the generated file
        let content = fs.readFileSync(`${tmp}.bundle.inner.js`, 'utf-8');
        let replace= content;
        // PATCHES all over the place
        //let replace = content.replace(/exports.javyinit/g, "// REMOVED");
        //replace = replace.replace(/exports.javyprocessmessage/g, "// REMOVED");
        //replace = replace.replace(/exports.javyregisternode/g, "// REMOVED");


        // replace = replace.replace(/export function/gi, "function");
        // console.log(replace.indexOf("export function"));

        // replace = replace.replace(/function javyregisternode/g, "export function javyregisternode");
        // replace = replace.replace(/function javyinit/g, "export function javyinit");
        // replace = replace.replace(/function javyprocessmessage/g, "export function javyprocessmessage");

        // replace = replace.replace(/Object.defineProperty\(exports/g, "try { let exports = {};} catch(e){} \nObject.defineProperty(exports");
        //replace = 'let exports = {};\n' + replace;
        // console.log(replace);

        // replace = replace.replace(/global\./g, "commonjsGlobal.");

        /*replace = `const process = {
            env: {

            },
            platform: 'Javy',
            cwd: '${filedir}',
            version: 'javy0.1'

            // Mock the process
          };\n
          ` + replace;*/
        // Replace the last line
        //let lines = replace.split("\n");
        //lines[lines.length-2] = "//module.exports";
        // Put back all together
        //replace = lines.join("\n");
        // replace = replace.replace(/module.exports/g, "//module.exports");

        fs.writeFileSync(`${tmp}.bundle.inner.js`, replace);

        
        // Call javy by default
        let cmd = `${thisdir}/bin/javy compile --file-permissions ${thisdir}/templates/permissions.yaml --wit ${thisdir}/templates/export.wit -n "node-red" ${tmp}.bundle.inner.js -o ${tmp}.wasm`;
        
        if(DEBUG){
            console.log("[WASM-RED] Compiling Wasm file", `${tmp}.bundle.inner.js`);
        }
        let sync = true;

        let rrt = execS(cmd);
        let name = `${tmp}.wasm`;

        if(false){//ops.optimize) {
            
            let cmd = `wasm-opt -all -O3 ${tmp}.wasm -o ${tmp}.opt.wasm`;
            if(DEBUG){
                console.log("[WASM-RED] Compiling Wasm file", `${tmp}.bundle.inner.js`);
            }
            let rrt = execS(cmd);
            name = `${tmp}.opt.wasm`;
            // Print the difference in size
            let size = fs.statSync(`${tmp}.wasm`).size;
            let size_opt = fs.statSync(`${tmp}.opt.wasm`).size;

            if(DEBUG){
                console.log(`[WASM-RED] Optimized from ${size} to ${size_opt} bytes (${size_opt/size*100}%)`);
            }
        }
        // hash the node code

        // let wasmbytes = fs.readFileSync(name);
        // Compile the Wasm module
        let wasm = new WebAssembly.Module(
            fs.readFileSync(name),
        );

        if(DEBUG){
            console.log(`[WASM-RED] Compiled wasm to cache ${name}`);
        }
        GLOBAL_CACHE[node_hash] = [wasm, `${tmp}.wrapper.js`];

        //console.log("Initializing")

        // Initialize

        const wasi = new WASI.WASI({
            version: 'preview1',
            args: [ /* empty for now */ ],
            env: { /* empty for now */ },
            preopens: {
            // '/sandbox': '/dev/',
            },
        });
        // The result if the STACK
        INSTANCE_CACHE[node_hash] = {
            RESULT:[],
            INSTANCE: null
        }

        // Initialize

        let rendered_wasm = mustache.render(fs.readFileSync(wasm_wasi, 'utf-8'), {
            wasmfile: node_hash,
            debug: 1,
            time: ops.time
        })

        // This is jsut for debug, remove after
        fs.writeFileSync(`${tmp}.wrapper.js`, rendered_wasm);
        return [rendered_wasm, `${tmp}.wrapper.js`]
        // Render the code template
        // Return the call to the fresh Wasm code
    },
    wasmwrap_jseval: function(node, ops = {}) {
        
        const { duktapeEval, quickjsEval } = require('wasm-jseval');

        duktapeEval.getInstance().then(mod => {
            let r = mod.eval(node)
        })

    }
}