const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const types = require('@babel/types');
const { filter } = require('cheerio/lib/api/traversing');
const generator = require('@babel/generator').default;
const fs = require('fs');
const mustache =require('mustache');
const { Exception } = require('sass');

const listenername = "mm";

function _(c, els = undefined) {
    try{
        return c()
    } catch(e) {
        console.log(e)

        if(els) {
            return _(els);
        }
    }
}

module.exports = {
    wasmwrap : function(node) {
        let f = node.file;
        
        console.log(node.name, f)
        // Read the JavaScript file
        const code = fs.readFileSync(f, 'utf-8');
        let rr = require(f);


        // Parse the code into an AST
        const ast = parser.parse(code, {
        sourceType: 'module',
            plugins: [
                // Enable any necessary syntax plugins here
        ],
        });


        // Traverse the AST
        console.log("Traversing AST");
        let WASMCOUNT = 0;

        // We go bottom up
        // The easiest transformation is a single arithm instruction
        // We need to take all "requires" to run rollup on them

        let idval = {};
        let declarations = [];
        let dependencies = [];

        _(() => {
        traverse(ast, {
            // Parse the require statements
            // Group them all to ask for rollup
            VariableDeclaration(path) {
                let names = path.node.declarations.map((d) => [d.id.name, d.init, d, d.type]);
                names = names.filter((n) => n[1]);
                // Add the declarations as nodes
                
                for(let n of names) {
                    // console.log(n);
                    let init = n[1];
                    let name = n[0];
                    //console.log("Adding declaration", name);
                    _(() => {
                    const id = types.identifier(name);
                    declarations.push(
                        types.variableDeclaration("let", [
                            types.variableDeclarator(id)
                        ])
                    );
                    if(init){
                        //console.log(init);
                        declarations.push(types.tryStatement(
                        types.blockStatement([
                            types.expressionStatement(
                                types.assignmentExpression("=", id, init)
                            )
                        ]), types.catchClause(types.identifier("e"), types.blockStatement([
                            //types.expressionStatement(types.callExpression(types.identifier("console.log"), [types.identifier("e")]))
                        ]))
                    ), );}

                    })
                }

                for(let n of names) {
                    let init = n[1];
                    let name = n[0];

                    if(init.type == "CallExpression" && init.callee.name == "require") {
                        // Save this a dependency
                        dependencies.push(n[2]);
                    }

                    // Just try to eval
                    // Just add all declarations one after the other to the declarations array
                    let previous = _(() =>{
                        const ret = types.returnStatement(init);
                        // Create an empty function
                        return types.blockStatement([...declarations, ret ]);
                    })

                    //console.log("prev");
                    let code = _( () => generator(previous).code );
                    //console.log(code)
                    try {
                        // TODO watch out, this is dangerous
                        let value = new Function(code)();
                        idval[name] = value;

                    } catch(e) {
                       // console.log(e);
                    }

                    
                }
            },
            CallExpression(path) {
                const callee = path.node.callee;
                
                if (!callee)
                    return;

                const name = path.node.callee.name;
                const tpe = callee.type;
                const pr = callee.property;

                if(pr && pr.name) {
                    // We are assuming that there is not other "on" call for "input" events
                    if(pr.name === "on") {
                        if(pr.name) {
                            console.log(name, tpe, pr.name);
                            console.log("=================");
                        }

                        const arguments = path.node.arguments;
                        if(arguments.length > 1) {
                            const first = arguments[0];
                            // If it is a string, it is the event name
                            let eventname;
                            if(first.type === "StringLiteral") {
                                eventname = first.value;
                            } 
                            else {
                                // Track back the variable for the event name
                                if(first.type === "Identifier") {
                                    // If it was seen then we can get the value
                                    if(idval[first.name]) {
                                        eventname = idval[first.name];
                                    }
                                }

                                // The other cases
                            }
                            console.log("\tEvent name", eventname);

                            if(eventname == "input") {
                                // The second argument is the function
                                let second = arguments[1];

                                if(second)
                                {
                                    // If second is not a function, we need to do something
                                    // We can partially evaluate it as we did with the event name
                                    // If it is an identifier, we can get the value
                                    if(second.type === "Identifier") {
                                        let val = idval[second.name].toString();
                                        let val2;
                                        // Parse the listener code
                                        _(() => val2 = parser.parse(val), () => {
                                            // If it fails and it is an anonymous function, we patch it :|
                                            // if idval[second.name]
                                            if(idval[second.name].constructor.name == "Function") {
                                                if(val.startsWith("function")) {
                                                    val = val.replace("function", "function mm");
                                                    //console.log(val);
                                                    val2 = parser.parse(val, {
                                                        sourceType: 'script',
                                                    });
                                                }
                                            }
                                        });
                                        second = val2.program.body[0];
                                    }
                                    //console.log(second.params, second.body, second.generator, second.async);
                                    // Create a new main function from scratch


                                    // Copy out it as a string
                                    // TODO, do another pass to set the msg, send, done and get_node access
                                    //let code = generator(second).code;
                                    // Get the body of the code and create a named function

                                    // Filter out dependencies by var name;
                                    // Doing Wasm
                                    WASMCOUNT += 1;
                                    let uniquenames = [];
                                    let uniquedeps = [];
                                    for(let d of dependencies) {
                                        let name = d.id.name;
                                        if(!uniquenames.includes(name)) {
                                            uniquenames.push(name);
                                            uniquedeps.push(d);
                                        }
                                    }
                                    const NN = `${listenername}${WASMCOUNT}`;
                                    console.log(NN);
                                    let functionmm = types.functionDeclaration(types.identifier(NN), second.params, second.body, second.generator, second.async);

                                    let rendered_wrapper = mustache.render(
                                        fs.readFileSync(`${__dirname}/templates/wrapper.js`, 'utf-8'), {
                                        inner_code: generator(functionmm).code,
                                        mm: NN,
                                        // Force dep as consts
                                        dependencies: uniquedeps.map((d) => `const ${generator(d).code} `),
                                        args: second.params.map((p) => p.name),
                                        debug: true,
                                        orig : f
                                    })


                                    
                                    // Add the requires
                                    // Add the entry points

                                    let r = fs.writeFileSync(`${f}.inner.${WASMCOUNT}.js`, rendered_wrapper);
                                    console.log("\tWasm Code generated !");
                                    // replace it with a custom code
                                    // Load the wasi_template
                                    let template_path = `${__dirname}/templates/wasm-wasi.js`;
                                    let rendered = mustache.render(fs.readFileSync(template_path, 'utf-8'), {
                                        wasmfile: `${f}.inner.${WASMCOUNT}.wasm`,
                                    })
                                    // Change the second argument to be a function with the same signature as
                                    // the original one, but with the body replaced by the wasm code
                                    // TODO this can be a call to a variable that is declared as the listener :|
                                    let signature = second.params.map((p) => types.identifier(p.name));
                                    //console.log(signature);
                                    //let body = rendered;
                                    let parsed_template = // Parse the rendered code
                                    parser.parse(rendered, {
                                        // allow async
                                        sourceType: 'module',
                                    });
                                    //console.log(parsed_template.program.body)
                                    let newfunc = _(() => types.functionExpression(null, signature, 
                                        types.blockStatement(parsed_template.program.body), undefined, true
                                        ));
                                    //console.log(newfunc);
                                    arguments[1] = newfunc;
                                    console.log("\JS Code generated !");
                                }
                            }
                        }
                    }
                }
            },
            // We do some replacement here if needed
        }) });

        // Now call rollup (or vivet) for the inner file


        const newCode = _(() => generator(ast).code);
        // Compile the whole AST to Wasm
        let thisdir = __dirname;
        let execS = require('child_process').execSync;

        // TODO find the location of the package.json file

        function get_package_json_folder(f) {

            // Start by this file and go to parent until package.json is found
            // make this a function
            let current = f;
            let found = false;
            while(!found) {
                let files = fs.readdirSync(current);
                if(files.includes("package.json")) {
                    found = true;
                } else {
                    current = current.split("/").slice(0, -1).join("/");
                }
            }
            return current;
        }
        
        // Compile each detected Wasm
        for(let C = 1; C <= WASMCOUNT; C++) {
            let rollup = `rollup  ${f}.inner.${C}.js --config ${thisdir}/configs/rollup.config.js --bundleConfigAsCjs --file ${f}.bundle.inner.${C}.js`
            
            // TODO fix this ugly hack
            let filedir = get_package_json_folder(f.split("/").slice(0, -1).join("/"));

            console.log(filedir);
            execS(rollup, {
                // Set the CWD on the folder of the file
                cwd: filedir
            });
            // Patch the generated file
            let content = fs.readFileSync(`${f}.bundle.inner.${C}.js`, 'utf-8');
            // Is the last apparison of this
            let replace = content.replace(/main\(\);\n\nmodule.exports/g, "main();\n//module.exports");
            replace = replace.replace(/modules.exports/g, "//modules.exports");

            fs.writeFileSync(`${f}.bundle.inner.${C}.js`, replace);

            let cmd = `${thisdir}/javy/javy compile ${f}.bundle.inner.${C}.js -o ${f}.inner.${C}.wasm`;
            console.log("Compiling Wasm file")
            // Make exec sync
            let sync = true;

            let rrt = execS(cmd);
            console.log(rrt.toString());

            // TODO test the wrapping
            // If so, change the logo

        }
        // Write the new code to a file
        console.log("Glue code generated");
        fs.writeFileSync(`${f}.wrapped.js`, newCode);
        console.log("Wrapper generated");
        // Do change meta in the html content

        // Change the icon in the HTML file corresponding to this JS
        // Remove previous extension
        let nonext = f.split(".")[0];
        let html_file = `${nonext}.html`;
        let html_content = fs.readFileSync(html_file, 'utf-8');
        // change the icon
        let new_html_content = html_content.replace(/icon: ".*"/, `icon: "wasm.png"`);
        // Save back
        fs.writeFileSync(html_file, new_html_content);

        return require(`${f}.wrapped.js`)
    },
    wasmwrap_code: function(node) {
        console.log("wrapping ", node)

        let template_path = `${__dirname}/templates/wrapper.js`;
        // Render
        let rendered = mustache.render(fs.readFileSync(template_path, 'utf-8'), {
            inner_code: `function mm(){${node}}`,
            mm: "mm",
        });

        // write to tmp file
        fs.writeFileSync("tmp.js", rendered);

        // Call rollup

        // Call javy

        let thisdir = __dirname;
        let execS = require('child_process').execSync;

        let cmd = `${thisdir}/javy/javy compile tmp.js -o temp.wasm`;
        console.log("Compiling Wasm file")
        // Make exec sync
        let sync = true;

        let rrt = execS(cmd);

        // Create the Wasm as tmp
        // hash the node code

        let wasm_wasi = `${__dirname}/templates/wasm-wasi-dyn.js`;
        let rendered_wasm = mustache.render(fs.readFileSync(wasm_wasi, 'utf-8'), {
            wasmfile: `temp.wasm`,

        })

        fs.writeFileSync("tmp.wrapper.js", rendered_wasm);
        return rendered_wasm
        // Render the code template
        // Return the call to the fresh Wasm code
    }
}